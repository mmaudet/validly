---
phase: 10-am-liorer-gestion-demandes-et-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/api/routes/workflows.ts
  - backend/src/api/routes/actions.ts
  - backend/src/api/routes/users.ts
  - backend/src/services/workflow-service.ts
  - backend/src/services/user-service.ts
  - backend/src/app.ts
autonomous: true
requirements:
  - WORKFLOW-CANCEL
  - WORKFLOW-RENOTIFY
  - ACTION-TOKEN-INFO
  - USER-CRUD

must_haves:
  truths:
    - "Initiator can cancel an in-progress workflow via PATCH /workflows/:id/cancel"
    - "Initiator can re-send notifications to pending validators via POST /workflows/:id/notify"
    - "Frontend can fetch workflow summary from an action token without consuming it via GET /actions/:token/info"
    - "Admin can create, list, update, and delete users via /users endpoints"
    - "All authenticated users can list users (for validator picker)"
  artifacts:
    - path: "backend/src/api/routes/workflows.ts"
      provides: "Cancel and notify endpoints"
      contains: "cancel"
    - path: "backend/src/api/routes/actions.ts"
      provides: "Token info endpoint"
      contains: "/info"
    - path: "backend/src/api/routes/users.ts"
      provides: "Admin user CRUD routes"
      exports: ["userRoutes"]
    - path: "backend/src/services/user-service.ts"
      provides: "User CRUD business logic"
      contains: "userService"
    - path: "backend/src/services/workflow-service.ts"
      provides: "cancel and notifyCurrentStep methods"
      contains: "cancel"
  key_links:
    - from: "backend/src/api/routes/workflows.ts"
      to: "backend/src/services/workflow-service.ts"
      via: "cancel() and notifyCurrentStep() calls"
      pattern: "workflowService\\.(cancel|notifyCurrentStep)"
    - from: "backend/src/api/routes/users.ts"
      to: "backend/src/services/user-service.ts"
      via: "CRUD operations"
      pattern: "userService\\."
    - from: "backend/src/app.ts"
      to: "backend/src/api/routes/users.ts"
      via: "route registration"
      pattern: "userRoutes"
---

<objective>
Backend API endpoints: workflow cancellation, manual re-notification, action token info, and admin user CRUD.

Purpose: Provides all the new REST API endpoints that the frontend plans (03, 04, 05) will consume.
Output: Four new API capabilities — cancel workflow, re-notify step, get token info, and full user management.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-am-liorer-gestion-demandes-et-ux/10-CONTEXT.md
@.planning/phases/10-am-liorer-gestion-demandes-et-ux/10-RESEARCH.md

@backend/src/api/routes/workflows.ts
@backend/src/api/routes/actions.ts
@backend/src/services/workflow-service.ts
@backend/src/services/token-service.ts
@backend/src/services/auth-service.ts
@backend/src/app.ts
@backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Workflow cancel, re-notify endpoints, and action token info</name>
  <files>
    backend/src/api/routes/workflows.ts
    backend/src/api/routes/actions.ts
    backend/src/services/workflow-service.ts
  </files>
  <action>
    Add three new endpoints and their service methods.

    **1. Workflow cancel — `PATCH /workflows/:id/cancel`**

    In `workflow-service.ts`, add a `cancel(workflowId: string, initiatorId: string)` method:
    - Load workflow with phases -> steps
    - Guard: workflow must exist (404), initiator must match `workflow.initiatorId` (403), status must be `IN_PROGRESS` (409)
    - In a transaction:
      a. Set `workflow.status = 'CANCELLED'`
      b. Find all `IN_PROGRESS` steps and expire their active tokens: `actionToken.updateMany({ where: { stepId: { in: activeStepIds }, usedAt: null }, data: { expiresAt: new Date(0) } })`
      c. Create an audit event: `action: 'WORKFLOW_CANCELLED'`, `entityType: 'workflow'`, `entityId: workflowId`
    - After transaction: remove BullMQ reminder jobs for all steps. Import `cancelReminder` from `reminder-service`. For each step across all phases: `cancelReminder(step.id)` (wrapped in try/catch).
    - NOTE: Plan 01 creates `reminder-service.ts` with `cancelReminder`. If building in parallel, add a TODO import and implement a stub that does nothing if the module doesn't exist yet. Alternatively, check if `reminder-service` exists at import time.

    In `routes/workflows.ts`, add route:
    ```
    app.patch('/workflows/:id/cancel', { preHandler: [authenticate] }, async (req, reply) => {
      const { id } = req.params;
      const user = req.user; // from JWT
      await workflowService.cancel(id, user.sub);
      return reply.status(200).send({ message: 'Workflow cancelled' });
    });
    ```

    **2. Manual re-notify — `POST /workflows/:id/notify`**

    In `workflow-service.ts`, add a `notifyCurrentStep(workflowId: string, initiatorId: string)` method:
    - Load workflow with phases -> steps -> actions, and initiator + documents
    - Guard: initiator must match (403)
    - Find the active phase (`status: 'IN_PROGRESS'`) and active step
    - If no active step, throw 409 "No active step to notify"
    - Determine pending validators: `step.validatorEmails.filter(email => !step.actions.map(a => a.actorEmail).includes(email))`
    - If no pending validators, throw 409 "All validators have acted"
    - Call the existing `notifyValidators()` function with the pending emails (this creates new tokens and sends emails)

    In `routes/workflows.ts`, add route:
    ```
    app.post('/workflows/:id/notify', { preHandler: [authenticate] }, async (req, reply) => {
      const { id } = req.params;
      await workflowService.notifyCurrentStep(id, req.user.sub);
      return reply.status(200).send({ message: 'Notifications sent' });
    });
    ```

    **3. Action token info — `GET /actions/:token/info`**

    In `routes/actions.ts`, add a NEW route (no auth required — tokenless access):
    ```
    app.get('/actions/:token/info', async (req, reply) => {
      const { token } = req.params;
      const result = await tokenService.validateToken(token);
      if (!result.valid) {
        return reply.status(410).send({ reason: result.reason });
      }
      // Return workflow summary without consuming the token
      // Need to load the step -> phase -> workflow -> initiator -> documents
      const step = await prisma.stepInstance.findUnique({
        where: { id: result.stepId },
        include: {
          phase: {
            include: {
              workflow: {
                include: {
                  initiator: { select: { name: true } },
                  documents: { include: { document: { select: { title: true } } } },
                },
              },
            },
          },
        },
      });
      if (!step) return reply.status(404).send({ message: 'Step not found' });
      return reply.send({
        action: result.action,
        workflowTitle: step.phase.workflow.title,
        stepName: step.name,
        phaseName: step.phase.name,
        initiatorName: step.phase.workflow.initiator.name,
        documents: step.phase.workflow.documents.map(d => d.document.title),
      });
    });
    ```

    NOTE: The `tokenService.validateToken()` returns `{ valid, stepId, action, reason }`. Check the actual return shape in `token-service.ts` and adapt field names accordingly.
    NOTE: This endpoint does NOT require JWT auth — it uses the action token for authorization (same as the existing action execution flow).
  </action>
  <verify>
    - `npm run build` (backend) compiles without errors
    - `grep "cancel\|notifyCurrentStep" backend/src/services/workflow-service.ts` shows both methods
    - `grep "PATCH.*cancel\|POST.*notify" backend/src/api/routes/workflows.ts` shows both routes
    - `grep "actions.*info" backend/src/api/routes/actions.ts` shows the token info route
  </verify>
  <done>PATCH /workflows/:id/cancel cancels workflow and expires tokens, POST /workflows/:id/notify re-sends emails to pending validators, GET /actions/:token/info returns workflow summary from token</done>
</task>

<task type="auto">
  <name>Task 2: Admin user CRUD routes and service</name>
  <files>
    backend/src/api/routes/users.ts
    backend/src/services/user-service.ts
    backend/src/app.ts
  </files>
  <action>
    Create user management API with role-based access.

    **1. Create `backend/src/services/user-service.ts`:**

    - `listAll()`: Returns all users with `select: { id, name, email, role, locale, createdAt }` — no password field
    - `getById(id: string)`: Returns single user or throws 404
    - `create(data: { email, name, password, role, locale? })`:
      a. Check for existing email (throw 409 if duplicate)
      b. Hash password using the same pattern as `auth-service.ts` (scrypt via Node.js crypto)
      c. Create user with Prisma
      d. Return user without password
    - `update(id: string, data: { name?, role?, locale? })`:
      a. Find user or throw 404
      b. Update provided fields only
      c. Return updated user without password
    - `delete(id: string)`:
      a. Find user or throw 404
      b. Delete user (Prisma cascades handle related records)
      c. NOTE: Should NOT be able to delete self or the last admin. Add guard: count admins, if only 1 admin and trying to delete that admin, throw 409.

    **2. Create `backend/src/api/routes/users.ts`:**

    Export an async function `userRoutes(app: FastifyInstance)`.

    Create helper preHandlers:
    - `authenticate`: `await req.jwtVerify()` (reuse pattern from existing routes)
    - `requireAdmin`: authenticate + check `req.user.role === 'ADMIN'`, reply 403 if not

    Routes:
    - `GET /users` — preHandler: [authenticate] — returns `userService.listAll()`. All authenticated users can see the list (for validator picker — locked decision).
    - `POST /users` — preHandler: [requireAdmin] — body: `{ email, name, password, role, locale? }` — returns 201 + created user
    - `PATCH /users/:id` — preHandler: [requireAdmin] — body: `{ name?, role?, locale? }` — returns 200 + updated user
    - `DELETE /users/:id` — preHandler: [requireAdmin] — returns 204 no content

    Add basic validation:
    - POST: email required + valid format, name required (min 2 chars), password required (min 6 chars), role must be ADMIN/INITIATEUR/VALIDATEUR
    - PATCH: at least one field provided

    **3. Register routes in `app.ts`:**

    Import `userRoutes` and register: `app.register(userRoutes, { prefix: '/api' })` alongside the existing route registrations.

    NOTE: The existing route pattern in app.ts uses `app.register(fn, { prefix: '/api' })`. Follow the same pattern. Check if routes use `/users` or `/api/users` prefix — match existing convention.
  </action>
  <verify>
    - `npm run build` (backend) compiles without errors
    - `grep "userRoutes" backend/src/app.ts` confirms route registration
    - `grep "GET.*users\|POST.*users\|PATCH.*users\|DELETE.*users" backend/src/api/routes/users.ts` shows all 4 CRUD routes
    - `grep "requireAdmin" backend/src/api/routes/users.ts` confirms admin guard is applied
  </verify>
  <done>Admin can create/update/delete users with role assignment, all authenticated users can list users for validator picker, last-admin deletion is blocked, routes registered in app.ts</done>
</task>

</tasks>

<verification>
- `npm run build` in backend/ passes with zero errors
- All 4 new routes respond (cancel, notify, token info, users CRUD)
- Cancel endpoint expires tokens and creates audit event
- Notify endpoint re-sends emails to pending validators only
- Token info returns workflow summary without consuming the token
- User CRUD enforces admin-only for write operations
- User list is accessible to all authenticated users
</verification>

<success_criteria>
- PATCH /workflows/:id/cancel — cancels workflow, expires tokens, removes reminder jobs
- POST /workflows/:id/notify — re-sends notifications to pending validators on active step
- GET /actions/:token/info — returns workflow context from action token
- GET/POST/PATCH/DELETE /users — full admin CRUD with role guard
- All endpoints follow existing codebase patterns (JWT auth, error handling, Prisma queries)
</success_criteria>

<output>
After completion, create `.planning/phases/10-am-liorer-gestion-demandes-et-ux/10-02-SUMMARY.md`
</output>
