---
phase: 14-social-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/prisma/schema.prisma
  - backend/src/services/comment-service.ts
  - backend/src/services/notification-service.ts
  - backend/src/api/routes/comments.ts
  - backend/src/api/routes/notifications.ts
  - backend/src/app.ts
  - backend/src/services/workflow-service.ts
autonomous: true
requirements: [COMM-01, COMM-02, COMM-03, COMM-04, COMM-05, NOTIF-01, NOTIF-02, NOTIF-03, NOTIF-04, NOTIF-05, NOTIF-06, NOTIF-07]

must_haves:
  truths:
    - "POST /workflows/:id/comments creates a comment linked to the workflow and authenticated user"
    - "GET /workflows/:id/comments returns comments in chronological order"
    - "Only the workflow initiator and registered validators can post or view comments"
    - "GET /notifications returns the authenticated user's notifications, optionally filtered by unread"
    - "PATCH /notifications/:id/read marks a single notification as read"
    - "PATCH /notifications/read-all marks all unread notifications as read for the user"
    - "GET /users/me/notification-prefs returns the user's notification preference map"
    - "PUT /users/me/notification-prefs saves per-type enable/disable preferences"
    - "When a workflow step is approved or refused, notifications are created for participants (respecting preferences)"
    - "When a workflow completes or is refused terminally, notifications are created for the initiator"
    - "When a comment is added, notifications are created for other participants on that workflow"
  artifacts:
    - path: "backend/prisma/schema.prisma"
      provides: "WorkflowComment and Notification models, notificationPrefs on User"
      contains: "model WorkflowComment"
    - path: "backend/src/services/comment-service.ts"
      provides: "Comment business logic"
      exports: ["commentService"]
    - path: "backend/src/services/notification-service.ts"
      provides: "Notification business logic"
      exports: ["notificationService"]
    - path: "backend/src/api/routes/comments.ts"
      provides: "Comment REST endpoints"
      exports: ["commentRoutes"]
    - path: "backend/src/api/routes/notifications.ts"
      provides: "Notification REST endpoints"
      exports: ["notificationRoutes"]
  key_links:
    - from: "backend/src/services/workflow-service.ts"
      to: "backend/src/services/notification-service.ts"
      via: "notificationService.createNotification() calls after recordAction transaction commit"
      pattern: "notificationService\\.createNotification"
    - from: "backend/src/services/comment-service.ts"
      to: "backend/src/services/notification-service.ts"
      via: "addComment triggers COMMENT_ADDED notifications"
      pattern: "notificationService\\.createNotification"
    - from: "backend/src/api/routes/comments.ts"
      to: "backend/src/services/comment-service.ts"
      via: "route handlers call commentService methods"
      pattern: "commentService\\."
    - from: "backend/src/api/routes/notifications.ts"
      to: "backend/src/services/notification-service.ts"
      via: "route handlers call notificationService methods"
      pattern: "notificationService\\."
    - from: "backend/src/app.ts"
      to: "backend/src/api/routes/comments.ts"
      via: "Fastify plugin registration"
      pattern: "commentRoutes"
---

<objective>
Build the complete backend for workflow comments and in-app notifications: Prisma models, service layer, REST routes, and notification creation hooks wired into the existing workflow engine.

Purpose: Provides the data layer and API that the frontend (Plan 02) will consume. All 12 requirements have backend implications addressed here.
Output: 5 new files + 2 modified files. Full REST API for comments and notifications ready for frontend integration.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/prisma/schema.prisma
@backend/src/services/workflow-service.ts
@backend/src/api/routes/workflows.ts
@backend/src/api/routes/users.ts
@backend/src/app.ts
@backend/src/services/user-service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Prisma models for WorkflowComment and Notification, add notificationPrefs to User</name>
  <files>backend/prisma/schema.prisma</files>
  <action>
Add three changes to the existing schema.prisma:

1. Add `notificationPrefs Json?` field to the User model (mapped to "notification_prefs"). Also add relation fields `comments WorkflowComment[]` and `notifications Notification[]` to User.

2. Add WorkflowComment model:
```
model WorkflowComment {
  id         String   @id @default(cuid())
  workflowId String   @map("workflow_id")
  authorId   String   @map("author_id")
  body       String
  createdAt  DateTime @default(now()) @map("created_at")

  workflow WorkflowInstance @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  author   User             @relation(fields: [authorId], references: [id])

  @@index([workflowId])
  @@map("workflow_comments")
}
```
Also add the reverse relation `comments WorkflowComment[]` to WorkflowInstance model.

3. Add Notification model:
```
model Notification {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  type       String
  context    Json
  read       Boolean  @default(false)
  createdAt  DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([userId, createdAt])
  @@map("notifications")
}
```
Note: Notification.type is a plain String column, NOT a Prisma enum (per v1.1 constraint to avoid migration pitfalls).

After editing schema, run `cd backend && npx prisma db push` to sync the database.
Then run `npx prisma generate` to update the client.
  </action>
  <verify>
Run `cd backend && npx prisma validate` — must exit 0 with no errors.
Run `cd backend && npx prisma db push --force-reset` in dev if needed, or just `npx prisma db push`.
Confirm the generated client includes WorkflowComment and Notification by checking `node -e "const { PrismaClient } = require('@prisma/client'); const p = new PrismaClient(); console.log(typeof p.workflowComment, typeof p.notification)"` prints "object object".
  </verify>
  <done>
schema.prisma contains WorkflowComment model, Notification model, and notificationPrefs on User. Prisma client is regenerated. Database schema is synced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comment-service.ts and notification-service.ts</name>
  <files>backend/src/services/comment-service.ts, backend/src/services/notification-service.ts</files>
  <action>
**comment-service.ts:**

Create a new service file following the existing service pattern (see user-service.ts for reference). Export `commentService` object and `CommentError` class.

Methods:
- `addComment(workflowId: string, authorId: string, body: string)`:
  1. Validate body is non-empty (trim), throw CommentError(400) if empty.
  2. Load the workflow with initiator and all phases -> steps -> validatorEmails.
  3. Check workflow exists (404 if not).
  4. Check the author is either the workflow initiator OR their email appears in any step's validatorEmails. To do this, load the author user to get their email, then check `workflow.initiatorId === authorId` OR any step has `validatorEmails.includes(authorEmail)`. Throw CommentError(403, 'Not a participant in this workflow') if neither.
  5. Check workflow status is NOT in terminal states (APPROVED, REFUSED, CANCELLED, ARCHIVED). If terminal, throw CommentError(409, 'Cannot comment on a completed workflow').
  6. Create the WorkflowComment record via prisma.workflowComment.create().
  7. AFTER the create (not in a transaction), trigger COMMENT_ADDED notifications for all OTHER participants on this workflow (initiator + all unique validator emails who are registered users, excluding the comment author). Use notificationService.createNotification() for each. Wrap in try/catch so notification failure doesn't break the comment.
  8. Return the created comment with author info (include author: { select: { id, name, email } }).

- `listComments(workflowId: string, userId: string)`:
  1. Load the workflow with initiator and phases -> steps.
  2. Check workflow exists (404).
  3. Check the user is a participant (same check as addComment — initiator or validator). Throw 403 if not.
  4. Return prisma.workflowComment.findMany({ where: { workflowId }, orderBy: { createdAt: 'asc' }, include: { author: { select: { id: true, name: true, email: true } } } }).

**notification-service.ts:**

Create a new service file. Export `notificationService` object, `NotificationError` class, and `NOTIFICATION_TYPES` constant.

Constants:
```typescript
export const NOTIFICATION_TYPES = {
  STEP_APPROVED: 'STEP_APPROVED',
  STEP_REFUSED: 'STEP_REFUSED',
  WORKFLOW_COMPLETED: 'WORKFLOW_COMPLETED',
  WORKFLOW_REFUSED: 'WORKFLOW_REFUSED',
  COMMENT_ADDED: 'COMMENT_ADDED',
} as const;
```

Methods:
- `createNotification(userId: string, type: string, context: Record<string, unknown>)`:
  1. Check user's notificationPrefs (load user, parse notificationPrefs Json). If the user has explicitly disabled this notification type, skip (return null). Default is all types enabled if notificationPrefs is null.
  2. Create and return the Notification record.

- `listForUser(userId: string, options?: { unread?: boolean; limit?: number })`:
  1. Build where clause: { userId }. If options.unread is true, add { read: false }.
  2. Return prisma.notification.findMany({ where, orderBy: { createdAt: 'desc' }, take: options?.limit ?? 50 }).

- `getUnreadCount(userId: string)`:
  1. Return prisma.notification.count({ where: { userId, read: false } }).

- `markRead(id: string, userId: string)`:
  1. Find the notification by id. If not found or userId doesn't match, throw 404.
  2. Update read to true.

- `markAllRead(userId: string)`:
  1. prisma.notification.updateMany({ where: { userId, read: false }, data: { read: true } }).

- `getPreferences(userId: string)`:
  1. Load user, return notificationPrefs or default object `{ STEP_APPROVED: true, STEP_REFUSED: true, WORKFLOW_COMPLETED: true, WORKFLOW_REFUSED: true, COMMENT_ADDED: true }`.

- `updatePreferences(userId: string, prefs: Record<string, boolean>)`:
  1. Validate prefs keys are valid notification types. Ignore unknown keys.
  2. Update user.notificationPrefs = prefs via prisma.user.update().
  3. Return the saved prefs.
  </action>
  <verify>
TypeScript compilation: `cd backend && npx tsc --noEmit` — no errors related to the new service files.
Check imports resolve: both files should import from '../infrastructure/database.js' for prisma.
  </verify>
  <done>
comment-service.ts exports commentService with addComment and listComments methods. notification-service.ts exports notificationService with createNotification, listForUser, getUnreadCount, markRead, markAllRead, getPreferences, updatePreferences. Both follow established service patterns.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create REST routes, register in app.ts, wire notification hooks into workflow-service.ts</name>
  <files>backend/src/api/routes/comments.ts, backend/src/api/routes/notifications.ts, backend/src/app.ts, backend/src/services/workflow-service.ts</files>
  <action>
**comments.ts route file:**

Follow the exact pattern from workflows.ts (FastifyInstance plugin, authenticate preHandler, try/catch with service errors).

Routes:
- `GET /workflows/:id/comments` — authenticate, call commentService.listComments(id, user.sub), return array.
- `POST /workflows/:id/comments` — authenticate, body schema requires `{ body: string (minLength 1) }`, call commentService.addComment(id, user.sub, body.body), return 201 with created comment.

**notifications.ts route file:**

Routes:
- `GET /notifications` — authenticate, query params: `unread?: boolean, limit?: number (default 50)`. Call notificationService.listForUser(user.sub, { unread, limit }). Also include `unreadCount` in response by calling notificationService.getUnreadCount(user.sub). Return `{ notifications: [...], unreadCount: N }`.
- `PATCH /notifications/:id/read` — authenticate, call notificationService.markRead(id, user.sub), return 200.
- `PATCH /notifications/read-all` — authenticate, call notificationService.markAllRead(user.sub), return 200.
- `GET /users/me/notification-prefs` — authenticate, call notificationService.getPreferences(user.sub), return prefs object.
- `PUT /users/me/notification-prefs` — authenticate, body is `Record<string, boolean>`, call notificationService.updatePreferences(user.sub, body), return updated prefs.

IMPORTANT: Register the `PATCH /notifications/read-all` route BEFORE `PATCH /notifications/:id/read` to avoid Fastify treating "read-all" as an :id parameter.

**app.ts modifications:**

Add imports for commentRoutes and notificationRoutes. Register both with prefix '/api':
```typescript
import { commentRoutes } from './api/routes/comments.js';
import { notificationRoutes } from './api/routes/notifications.js';
// ... in buildApp():
await app.register(commentRoutes, { prefix: '/api' });
await app.register(notificationRoutes, { prefix: '/api' });
```

**workflow-service.ts modifications:**

Add notification hooks AFTER transaction commits in recordAction() method. Import notificationService at the top.

After the existing initiator email notification block (the try/catch around line 354-396), add a new try/catch block:

```typescript
// Create in-app notifications (after transaction commit, never inside $transaction)
try {
  const wfForNotif = await prisma.workflowInstance.findUnique({
    where: { id: workflow.id },
    include: {
      initiator: { select: { id: true } },
      phases: { include: { steps: { select: { validatorEmails: true } } } },
    },
  });
  if (wfForNotif) {
    // Collect all participant user IDs (initiator + registered validators)
    const allValidatorEmails = new Set<string>();
    for (const phase of wfForNotif.phases) {
      for (const step of phase.steps) {
        for (const email of step.validatorEmails) {
          allValidatorEmails.add(email);
        }
      }
    }
    // Resolve validator emails to user IDs
    const validatorUsers = await prisma.user.findMany({
      where: { email: { in: [...allValidatorEmails] } },
      select: { id: true, email: true },
    });

    const notifContext = {
      workflowId: workflow.id,
      workflowTitle: workflow.title,
      stepName: step.name,
      actorEmail: input.actorEmail,
    };

    // Determine notification type
    const notifType = input.action === 'APPROVE'
      ? 'STEP_APPROVED'
      : 'STEP_REFUSED';

    // Notify all participants except the actor
    const recipientIds = [
      wfForNotif.initiator.id,
      ...validatorUsers.map(u => u.id),
    ].filter((id, idx, arr) => arr.indexOf(id) === idx); // deduplicate

    const actorUserId = input.actorId;
    for (const recipientId of recipientIds) {
      if (recipientId === actorUserId) continue; // don't notify yourself
      await notificationService.createNotification(recipientId, notifType, notifContext);
    }

    // If workflow reached terminal state, send WORKFLOW_COMPLETED or WORKFLOW_REFUSED
    const isTerminal =
      result.workflowAdvanced === true ||
      (result.newStepStatus === 'REFUSED' && result.activatedStep === null && result.stepCompleted);

    if (isTerminal) {
      const terminalType = result.workflowAdvanced ? 'WORKFLOW_COMPLETED' : 'WORKFLOW_REFUSED';
      const terminalContext = {
        workflowId: workflow.id,
        workflowTitle: workflow.title,
      };
      // Notify initiator (primary recipient for terminal notifications)
      await notificationService.createNotification(wfForNotif.initiator.id, terminalType, terminalContext);
    }
  }
} catch (err) {
  console.error('Failed to create in-app notifications:', err);
}
```

This follows the critical constraint: notification creation is NEVER inside prisma.$transaction(), always after commit, wrapped in try/catch.
  </action>
  <verify>
1. `cd backend && npx tsc --noEmit` — no TypeScript errors.
2. Start the backend: `cd backend && npm run dev` — server starts without errors.
3. Test comment endpoints with curl:
   - `curl -X POST http://localhost:3000/api/workflows/{id}/comments -H "Authorization: Bearer {token}" -H "Content-Type: application/json" -d '{"body":"Test comment"}' ` — returns 201.
   - `curl http://localhost:3000/api/workflows/{id}/comments -H "Authorization: Bearer {token}"` — returns array with the comment.
4. Test notification endpoints:
   - `curl http://localhost:3000/api/notifications -H "Authorization: Bearer {token}"` — returns { notifications: [], unreadCount: 0 }.
   - `curl http://localhost:3000/api/users/me/notification-prefs -H "Authorization: Bearer {token}"` — returns default prefs object.
  </verify>
  <done>
Comment routes (GET/POST /workflows/:id/comments) respond correctly. Notification routes (GET /notifications, PATCH /notifications/:id/read, PATCH /notifications/read-all, GET/PUT /users/me/notification-prefs) respond correctly. Workflow engine creates notifications after step actions and workflow terminal states. All notification creation is outside transactions, wrapped in try/catch.
  </done>
</task>

</tasks>

<verification>
1. Backend compiles: `cd backend && npx tsc --noEmit` exits 0
2. Prisma schema valid: `cd backend && npx prisma validate` exits 0
3. Server starts: `cd backend && npm run dev` logs no errors
4. Comment CRUD works via curl against running server
5. Notification CRUD works via curl against running server
6. Notification preferences CRUD works via curl
</verification>

<success_criteria>
- WorkflowComment and Notification models exist in schema.prisma with correct relations
- User model has notificationPrefs Json? field
- comment-service.ts provides addComment (with participant check and terminal state guard) and listComments
- notification-service.ts provides createNotification (respecting user prefs), listForUser, getUnreadCount, markRead, markAllRead, getPreferences, updatePreferences
- Comment routes respond at /workflows/:id/comments
- Notification routes respond at /notifications, /notifications/:id/read, /notifications/read-all, /users/me/notification-prefs
- workflow-service.ts creates STEP_APPROVED/STEP_REFUSED notifications after recordAction, WORKFLOW_COMPLETED/WORKFLOW_REFUSED on terminal state
- All notification creation is outside $transaction(), after commit, in try/catch
</success_criteria>

<output>
After completion, create `.planning/phases/14-social-features/14-01-SUMMARY.md`
</output>
