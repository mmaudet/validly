---
phase: 10-am-liorer-gestion-demandes-et-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/prisma/schema.prisma
  - backend/prisma/migrations/
  - backend/src/infrastructure/queue/index.ts
  - backend/src/jobs/reminder-worker.ts
  - backend/src/services/reminder-service.ts
  - backend/src/services/workflow-service.ts
  - backend/src/services/email-service.ts
  - backend/src/server.ts
  - backend/src/i18n/locales/en.json
  - backend/src/i18n/locales/fr.json
autonomous: true
requirements:
  - ROLE-MIGRATION
  - BULLMQ-REMINDERS
  - INITIATOR-EMAILS

must_haves:
  truths:
    - "UserRole enum has ADMIN, INITIATEUR, VALIDATEUR values and existing USER rows are migrated to INITIATEUR"
    - "BullMQ reminder worker processes delayed jobs and sends reminder emails to pending validators 24h before deadline"
    - "Initiator receives email when a validator approves or refuses"
    - "Initiator receives email when workflow is fully approved or refused"
    - "Reminder jobs are scheduled when a step with a deadline is activated"
  artifacts:
    - path: "backend/prisma/schema.prisma"
      provides: "Updated UserRole enum with ADMIN, INITIATEUR, VALIDATEUR"
      contains: "INITIATEUR"
    - path: "backend/src/infrastructure/queue/index.ts"
      provides: "BullMQ Queue and Redis connection exports"
      exports: ["reminderQueue", "redisConnection"]
    - path: "backend/src/jobs/reminder-worker.ts"
      provides: "BullMQ Worker that processes deadline reminders"
      contains: "Worker"
    - path: "backend/src/services/email-service.ts"
      provides: "sendInitiatorAction and sendInitiatorComplete email methods"
      contains: "sendInitiatorAction"
    - path: "backend/src/services/reminder-service.ts"
      provides: "scheduleReminder and cancelReminder functions"
      contains: "scheduleReminder"
  key_links:
    - from: "backend/src/services/workflow-service.ts"
      to: "backend/src/services/email-service.ts"
      via: "sendInitiatorAction/sendInitiatorComplete calls in recordAction"
      pattern: "emailService\\.sendInitiator"
    - from: "backend/src/services/workflow-service.ts"
      to: "backend/src/services/reminder-service.ts"
      via: "scheduleReminder call after notifyValidators"
      pattern: "scheduleReminder"
    - from: "backend/src/server.ts"
      to: "backend/src/jobs/reminder-worker.ts"
      via: "import and start worker"
      pattern: "reminderWorker"
---

<objective>
Backend foundation: Prisma schema migration for 3-role RBAC, BullMQ deadline reminder infrastructure, and initiator email notifications.

Purpose: Establishes the backend foundation all other phase 10 plans depend on: the new role system, the background job infrastructure, and the new email notification types.
Output: Updated schema with 3 roles, working BullMQ reminder pipeline, two new email templates for initiator notifications.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-am-liorer-gestion-demandes-et-ux/10-CONTEXT.md
@.planning/phases/10-am-liorer-gestion-demandes-et-ux/10-RESEARCH.md

@backend/prisma/schema.prisma
@backend/src/server.ts
@backend/src/services/email-service.ts
@backend/src/services/workflow-service.ts
@backend/src/services/token-service.ts
@backend/src/config/env.ts
@backend/src/infrastructure/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prisma schema migration — 3-role UserRole enum</name>
  <files>
    backend/prisma/schema.prisma
    backend/prisma/migrations/ (new migration)
  </files>
  <action>
    Migrate the UserRole enum from `USER | ADMIN` to `ADMIN | INITIATEUR | VALIDATEUR`.

    1. Update `schema.prisma`:
       - Change `enum UserRole` to have values: `ADMIN`, `INITIATEUR`, `VALIDATEUR`
       - Update the default value on User.role from `@default(USER)` to `@default(INITIATEUR)`

    2. Create and apply a Prisma migration:
       - Run `npx prisma migrate dev --name add_role_enum --create-only` to generate migration SQL
       - BEFORE applying, edit the migration SQL to:
         a. Add the new values first: `ALTER TYPE "UserRole" ADD VALUE 'INITIATEUR'; ALTER TYPE "UserRole" ADD VALUE 'VALIDATEUR';`
         b. Then update existing rows: `UPDATE "users" SET "role" = 'INITIATEUR' WHERE "role" = 'USER';`
         c. Then rename/drop the old value. NOTE: PostgreSQL does not support removing enum values directly. The migration should:
            - Create a new enum type with the 3 values
            - Alter the column to use the new type
            - Drop the old type
            - Rename the new type to UserRole
         d. Use this SQL pattern for the migration:
            ```sql
            -- Add new values to existing enum
            ALTER TYPE "UserRole" ADD VALUE IF NOT EXISTS 'INITIATEUR';
            ALTER TYPE "UserRole" ADD VALUE IF NOT EXISTS 'VALIDATEUR';
            -- Migrate existing USER rows to INITIATEUR
            UPDATE "users" SET "role" = 'INITIATEUR' WHERE "role" = 'USER';
            -- Replace enum (cannot remove values, must recreate)
            ALTER TYPE "UserRole" RENAME TO "UserRole_old";
            CREATE TYPE "UserRole" AS ENUM ('ADMIN', 'INITIATEUR', 'VALIDATEUR');
            ALTER TABLE "users" ALTER COLUMN "role" DROP DEFAULT;
            ALTER TABLE "users" ALTER COLUMN "role" TYPE "UserRole" USING ("role"::text::"UserRole");
            ALTER TABLE "users" ALTER COLUMN "role" SET DEFAULT 'INITIATEUR';
            DROP TYPE "UserRole_old";
            ```
       - Run `npx prisma migrate dev` to apply
       - Run `npx prisma generate` to regenerate the client

    3. Update any existing auth-service code that references `UserRole.USER` to use `UserRole.INITIATEUR` (check `auth-service.ts` signup function).

    4. Update JWT payload types if they reference the old role values.
  </action>
  <verify>
    - `npx prisma migrate status` shows no pending migrations
    - `npx prisma validate` passes
    - `npm run build` (backend) compiles without errors
    - Check that `UserRole` type in generated Prisma client has ADMIN, INITIATEUR, VALIDATEUR
  </verify>
  <done>UserRole enum has 3 values (ADMIN, INITIATEUR, VALIDATEUR), existing USER rows migrated to INITIATEUR, schema validates, backend compiles</done>
</task>

<task type="auto">
  <name>Task 2: BullMQ reminder queue, worker, and scheduler</name>
  <files>
    backend/src/infrastructure/queue/index.ts
    backend/src/jobs/reminder-worker.ts
    backend/src/services/reminder-service.ts
    backend/src/services/workflow-service.ts
    backend/src/server.ts
  </files>
  <action>
    Build the BullMQ deadline reminder pipeline.

    1. Create `backend/src/infrastructure/queue/index.ts`:
       - Import `Queue` from `bullmq` and `IORedis` from `ioredis`
       - Create a shared Redis connection with `maxRetriesPerRequest: null` (BullMQ requirement)
       - Export `reminderQueue = new Queue('reminders', { connection })` and `redisConnection`
       - Use `env.REDIS_URL` for the connection string

    2. Create `backend/src/jobs/reminder-worker.ts`:
       - Import `Worker` from `bullmq`, `prisma`, `tokenService`, `emailService`, `redisConnection`
       - Create a Worker on the 'reminders' queue that:
         a. Extracts `stepId` from `job.data`
         b. Loads the step with phase -> workflow -> documents -> initiator
         c. If step is no longer `IN_PROGRESS`, returns early (already resolved)
         d. Finds validators who haven't acted yet (compare `workflowAction.actorEmail` against `step.validatorEmails`)
         e. For each pending validator, creates new tokens via `tokenService.createTokensForStep` and sends a reminder email via `emailService.sendReminder`
       - Attach `worker.on('error', (err) => console.error('Reminder worker error:', err))`
       - Attach `worker.on('failed', (job, err) => console.error('Reminder job failed:', job?.id, err))`
       - Export the worker instance

    3. Create `backend/src/services/reminder-service.ts`:
       - Import `reminderQueue` from the queue module
       - Export `scheduleReminder(stepId: string, deadline: Date)`:
         a. Calculate delay: `deadline.getTime() - Date.now() - 24 * 3600 * 1000` (24h before)
         b. If delay <= 0, skip (deadline is less than 24h away or already passed)
         c. Add job: `reminderQueue.add('deadline-reminder', { stepId }, { delay, jobId: \`reminder-\${stepId}\`, removeOnComplete: true, removeOnFail: false })`
         d. Catch and ignore "Job already exists" errors (idempotent)
       - Export `cancelReminder(stepId: string)`:
         a. `try { await reminderQueue.remove(\`reminder-\${stepId}\`) } catch {}`

    4. Wire reminder scheduling into `workflow-service.ts`:
       - Import `scheduleReminder` from reminder-service
       - In `launch()`, after `notifyValidators` for the first step: if `firstStep.deadline`, call `scheduleReminder(firstStep.id, firstStep.deadline)`
       - In `recordAction()`, after `notifyValidators` for `result.activatedStep`: load the activated step's deadline and call `scheduleReminder` if deadline exists
       - In `recordAction()`, when a step completes (stepCompleted=true): call `cancelReminder(input.stepId)` to clean up

    5. Wire the worker into `server.ts`:
       - Import the reminder worker: `import './jobs/reminder-worker.js';`
       - Add this import after `buildApp()` but before `app.listen()`, OR simply add it as a top-level side-effect import at the module level. The Worker auto-starts on import.
       - Add a log line: `app.log.info('Reminder worker started');`

    NOTE: Do NOT use QueueScheduler — it's not needed in BullMQ 5.x.
    NOTE: The `backend/src/infrastructure/queue/` directory already exists but is empty.
    NOTE: The `backend/src/jobs/` directory does NOT exist yet — create it.
  </action>
  <verify>
    - `npm run build` (backend) compiles without errors
    - Import graph is valid: queue/index.ts has no circular dependencies
    - `grep -r "reminderQueue" backend/src/` confirms queue is used in reminder-service and reminder-worker
    - `grep -r "scheduleReminder" backend/src/` confirms it's called in workflow-service
  </verify>
  <done>BullMQ reminder queue exported, worker processes deadline-reminder jobs, reminders are scheduled on step activation and cancelled on step completion, worker starts with the server</done>
</task>

<task type="auto">
  <name>Task 3: Initiator email notifications on validator action and workflow completion</name>
  <files>
    backend/src/services/email-service.ts
    backend/src/services/workflow-service.ts
    backend/src/i18n/locales/en.json
    backend/src/i18n/locales/fr.json
  </files>
  <action>
    Add two new email methods for notifying the workflow initiator.

    1. In `email-service.ts`, add interfaces and methods:

       a. `InitiatorActionEmailInput`:
          - `to`, `locale`, `workflowTitle`, `stepName`, `actorEmail`, `actionType` ('APPROVE' | 'REFUSE'), `comment`, `workflowUrl`

       b. `sendInitiatorAction(input: InitiatorActionEmailInput)`:
          - Subject: use i18n key `email.initiator_action_subject` with workflowTitle interpolation
          - HTML body: inform the initiator that `actorEmail` has approved/refused at step `stepName`, include the comment, include a "View workflow" button linking to `workflowUrl`
          - Follow the same HTML email style as `sendPendingAction` (inline styles, Arial, max-width 600px)

       c. `InitiatorCompleteEmailInput`:
          - `to`, `locale`, `workflowTitle`, `finalStatus` ('APPROVED' | 'REFUSED'), `workflowUrl`

       d. `sendInitiatorComplete(input: InitiatorCompleteEmailInput)`:
          - Subject: use i18n key `email.initiator_complete_subject` with workflowTitle interpolation
          - HTML body: inform the initiator their workflow has been approved/refused globally, include a "View workflow" button
          - Use green styling for APPROVED, red for REFUSED

    2. In `workflow-service.ts recordAction()`, AFTER the transaction commit and after the existing `notifyValidators` block:

       a. Load the workflow with initiator: `prisma.workflowInstance.findUnique({ where: { id: workflow.id }, include: { initiator: true } })`
          - NOTE: The `wf` variable may already be loaded above for notifyValidators — reuse it if it includes initiator, or load separately
       b. Always call `emailService.sendInitiatorAction(...)` with the initiator's email, locale, workflowTitle, stepName, actorEmail, action type, comment, and workflowUrl (`${env.APP_URL}/workflows/${workflow.id}`)
       c. If the workflow has completed (check: `result.workflowAdvanced === true` OR `result.newStepStatus === 'REFUSED'` and no activatedStep was returned meaning the refusal refused the whole workflow), also call `emailService.sendInitiatorComplete(...)` with finalStatus derived from workflow terminal status

       NOTE: `env.APP_URL` may not exist yet. Check `backend/src/config/env.ts` — if APP_URL is not defined, add it to the env config with a default of `http://localhost:5173` (the Vite frontend URL). This is used to build links back to the frontend in emails.

    3. Add i18n keys to both EN and FR locale files:
       - `email.initiator_action_subject`: "{{workflowTitle}} — New action" / "{{workflowTitle}} — Nouvelle action"
       - `email.initiator_complete_subject`: "{{workflowTitle}} — Completed" / "{{workflowTitle}} — Terminé"

    4. Wrap all email sends in try/catch to avoid breaking the workflow on email failure (same pattern as existing `notifyValidators`).
  </action>
  <verify>
    - `npm run build` (backend) compiles without errors
    - `grep "sendInitiatorAction\|sendInitiatorComplete" backend/src/services/email-service.ts` shows both methods exist
    - `grep "sendInitiatorAction\|sendInitiatorComplete" backend/src/services/workflow-service.ts` shows both are called in recordAction
    - `grep "initiator_action_subject\|initiator_complete_subject" backend/src/i18n/locales/en.json backend/src/i18n/locales/fr.json` shows i18n keys in both locales
  </verify>
  <done>Initiator receives email on every validator action (approve/refuse) with details and comment, and a separate completion email when workflow reaches terminal state (approved/refused)</done>
</task>

</tasks>

<verification>
- `npm run build` in backend/ passes with zero errors
- `npx prisma validate` passes
- Schema has 3-role UserRole enum
- BullMQ imports resolve correctly (no missing modules)
- Email service has 4 methods: sendPendingAction, sendReminder, sendInitiatorAction, sendInitiatorComplete
- Reminder scheduling is wired into workflow-service (launch + recordAction)
- Reminder cancellation happens on step completion
- Worker is started in server.ts
</verification>

<success_criteria>
- Prisma schema migrated to ADMIN/INITIATEUR/VALIDATEUR with data migration for existing USER rows
- BullMQ reminder queue + worker + scheduler fully operational
- Initiator email notifications sent on validator action and workflow completion
- Backend compiles and all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-am-liorer-gestion-demandes-et-ux/10-01-SUMMARY.md`
</output>
