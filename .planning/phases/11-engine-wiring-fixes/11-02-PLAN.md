---
phase: 11-engine-wiring-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/workflow/TemplatePicker.tsx
  - frontend/src/pages/WorkflowCreatePage.tsx
  - backend/prisma/migrations/
  - backend/package.json
autonomous: true
requirements: [WF-08, AUDIT-02]

must_haves:
  truths:
    - "Loading a template into the circuit builder correctly populates execution mode for all steps"
    - "An attempted UPDATE on audit_events fails at the PostgreSQL level with an exception"
    - "An attempted DELETE on audit_events fails at the PostgreSQL level with an exception"
    - "The audit immutability triggers are applied automatically via prisma migrate deploy (no manual psql step)"
  artifacts:
    - path: "frontend/src/components/workflow/TemplatePicker.tsx"
      provides: "Template type with correct 'execution' field name"
      contains: "execution: 'SEQUENTIAL' | 'PARALLEL'"
    - path: "frontend/src/pages/WorkflowCreatePage.tsx"
      provides: "Template-to-form mapping using step.execution"
      contains: "step.execution"
    - path: "backend/prisma/migrations/"
      provides: "Prisma migration containing audit immutability trigger SQL"
    - path: "backend/package.json"
      provides: "Simplified db:setup script without manual psql step"
  key_links:
    - from: "frontend/src/components/workflow/TemplatePicker.tsx"
      to: "frontend/src/pages/WorkflowCreatePage.tsx"
      via: "Template type exported and consumed by templateStructureToForm()"
      pattern: "step\\.execution"
    - from: "backend/prisma/migrations/"
      to: "PostgreSQL audit_events table"
      via: "BEFORE UPDATE and BEFORE DELETE triggers"
      pattern: "BEFORE UPDATE ON audit_events"
---

<objective>
Fix the template field mismatch that breaks template loading in the circuit builder (WF-08) and promote the audit immutability SQL into a proper Prisma migration (AUDIT-02).

Purpose: Template-based workflow creation is a broken E2E flow — loading a template silently loses execution mode for all steps, making them default to undefined. The audit immutability triggers exist as SQL but are not applied automatically, meaning fresh deployments and CI lack the INSERT-only enforcement.

Output: Fixed TemplatePicker.tsx type + WorkflowCreatePage.tsx mapping, new Prisma migration with audit triggers, simplified db:setup script.
</objective>

<execution_context>
@/Users/mmaudet/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mmaudet/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-engine-wiring-fixes/11-RESEARCH.md
@frontend/src/components/workflow/TemplatePicker.tsx
@frontend/src/pages/WorkflowCreatePage.tsx
@backend/prisma/audit-immutability.sql
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix template type field mismatch (executionMode to execution)</name>
  <files>frontend/src/components/workflow/TemplatePicker.tsx, frontend/src/pages/WorkflowCreatePage.tsx</files>
  <action>
**TemplatePicker.tsx — Template interface (line 17):**
Change the step type field from `executionMode` to `execution`. This aligns the local TypeScript type with the backend JSON structure that stores the field as `execution`.

BEFORE (line 17):
```typescript
executionMode: 'SEQUENTIAL' | 'PARALLEL';
```

AFTER:
```typescript
execution: 'SEQUENTIAL' | 'PARALLEL';
```

No other changes to TemplatePicker.tsx. The component only passes the Template object to `onSelect` — it does not read `executionMode` or `execution` internally.

**WorkflowCreatePage.tsx — templateStructureToForm() (line 114):**
Change the property read from `step.executionMode` to `step.execution`. The Template type is imported from TemplatePicker.tsx, so after the type rename above, TypeScript will enforce this change.

BEFORE (line 114):
```typescript
executionMode: step.executionMode,
```

AFTER:
```typescript
executionMode: step.execution,
```

The form field name `executionMode` on the LEFT side stays as-is — this is intentional per the locked decision: "executionMode (form field) renamed to execution only in API payload builder — form type unchanged."

Do NOT change:
- `StepForm.executionMode` type — it stays as the form field name
- `buildWorkflowPayload()` — it already correctly maps `step.executionMode` to `execution` in the API payload
- Any other form-related code that uses `executionMode` as a form field name
  </action>
  <verify>
Run `npx tsc --noEmit` in the frontend directory (or `cd /Users/mmaudet/work/validly/frontend && npx tsc --noEmit`). Grep for `executionMode` in TemplatePicker.tsx — should return zero matches. Grep for `step.execution` in WorkflowCreatePage.tsx — should appear on the `templateStructureToForm` mapping line. Grep for `step.executionMode` in WorkflowCreatePage.tsx — should return zero matches (the old broken reference is gone).
  </verify>
  <done>
The Template type in TemplatePicker.tsx uses `execution` matching the backend JSON structure. The templateStructureToForm() function reads `step.execution` and maps it to the form's `executionMode` field. Loading a template correctly populates execution mode for all steps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Promote audit immutability SQL to Prisma migration and clean up db:setup</name>
  <files>backend/prisma/migrations/, backend/package.json</files>
  <action>
**Step 1: Create an empty Prisma migration shell.**
Run `cd /Users/mmaudet/work/validly/backend && npx prisma migrate dev --create-only --name add_audit_immutability_triggers`.

This creates a new migration directory at `backend/prisma/migrations/TIMESTAMP_add_audit_immutability_triggers/migration.sql` with an empty (or schema-diff-only) SQL file.

**Step 2: Write the audit immutability SQL into the migration file.**
Copy the full content of `backend/prisma/audit-immutability.sql` into the generated `migration.sql` file. The SQL is:

```sql
-- Enforce immutability on audit_events table at database level.

-- Prevent UPDATE
CREATE OR REPLACE FUNCTION prevent_audit_update()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'UPDATE operations are not allowed on audit_events table';
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS audit_no_update ON audit_events;
CREATE TRIGGER audit_no_update
  BEFORE UPDATE ON audit_events
  FOR EACH ROW
  EXECUTE FUNCTION prevent_audit_update();

-- Prevent DELETE
CREATE OR REPLACE FUNCTION prevent_audit_delete()
RETURNS TRIGGER AS $$
BEGIN
  RAISE EXCEPTION 'DELETE operations are not allowed on audit_events table';
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS audit_no_delete ON audit_events;
CREATE TRIGGER audit_no_delete
  BEFORE DELETE ON audit_events
  FOR EACH ROW
  EXECUTE FUNCTION prevent_audit_delete();
```

If the generated migration.sql already has content (Prisma schema diff), APPEND the trigger SQL after it. If it's empty, just write the trigger SQL.

**Step 3: Apply the migration.**
Run `cd /Users/mmaudet/work/validly/backend && npx prisma migrate dev`.

This will apply the migration to the local database. The SQL is idempotent (`CREATE OR REPLACE FUNCTION`, `DROP TRIGGER IF EXISTS`) so it's safe even if the triggers already exist from the manual psql step.

**Step 4: Simplify the db:setup script in package.json.**
In `backend/package.json`, change the `db:setup` script from:
```json
"db:setup": "prisma migrate dev && psql $DATABASE_URL -f prisma/audit-immutability.sql"
```
to:
```json
"db:setup": "prisma migrate dev"
```

The manual psql step is no longer needed because the trigger SQL is now part of the migration pipeline.

NOTE: The `audit-immutability.sql` file can remain in the repo as documentation, but it is no longer needed for setup. Do not delete it — it serves as a reference.
  </action>
  <verify>
Verify the migration directory exists: `ls backend/prisma/migrations/*audit_immutability*`. Verify the migration SQL contains the trigger functions: `grep "prevent_audit_update" backend/prisma/migrations/*audit_immutability*/migration.sql`. Verify db:setup no longer has psql: `grep "psql" backend/package.json` should return no matches. Test the triggers work: `cd /Users/mmaudet/work/validly/backend && npx prisma db execute --stdin <<< "UPDATE audit_events SET action='test' WHERE id='nonexistent'" 2>&1 | grep -i "not allowed"` — should show the exception message (or succeed silently if no rows match; the trigger fires BEFORE the row operation, so with a WHERE that matches no rows, no trigger fires). For a true verification, if audit_events has any rows: attempt an UPDATE on an existing row and confirm it raises "UPDATE operations are not allowed on audit_events table".
  </verify>
  <done>
The audit immutability triggers are in a proper Prisma migration that runs automatically with `prisma migrate deploy`. The db:setup script no longer requires a manual psql step. Fresh environments, CI, and staging deployments get the INSERT-only enforcement automatically.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/mmaudet/work/validly/frontend && npx tsc --noEmit` — zero type errors
2. `grep "executionMode" frontend/src/components/workflow/TemplatePicker.tsx` — zero matches
3. `grep "step.execution" frontend/src/pages/WorkflowCreatePage.tsx` — present in templateStructureToForm
4. `ls backend/prisma/migrations/*audit_immutability*` — migration directory exists
5. `grep "prevent_audit_update" backend/prisma/migrations/*audit_immutability*/migration.sql` — trigger function present
6. `grep "psql" backend/package.json` — zero matches (manual step removed)
</verification>

<success_criteria>
- Frontend TypeScript compiles without errors
- Template type uses `execution` field matching backend JSON
- templateStructureToForm reads `step.execution` and maps to form's `executionMode`
- Prisma migration exists with audit immutability trigger SQL
- db:setup script simplified (no manual psql step)
</success_criteria>

<output>
After completion, create `.planning/phases/11-engine-wiring-fixes/11-02-SUMMARY.md`
</output>
